main2_()
{
	unsigned int num1;
	num1 = 45;
	
	printf("%d\n", invert(num1, 4, 4));
}

unsigned invert(unsigned x, int p, int n)
{
	//int split[1000];
	/* 剔除待取反的值，并将原位归零 */
	//split = x & ~(~(~0 << n) << (p + 1 - n));
	//re = x & (~(~0 << n) << (p + 1 - n));
	return (x & ~(~(~0 << n) << (p + 1 - n))) & ~(x & (~(~0 << n) << (p + 1 - n)));  // 后半截失效，因为
	// 前半截p开始的n个位都为0，位与机制不能改变这些值。这就代码的实际作用是将从p开始的n个位都置为0
	//return x ^ (~(~0 << n) << (p + 1 - n));  // 与1进行异或运算，可得到反位。与0进行异或运算，不会改变
}

/*
位计数从0开始
题干：将x中从第p位开始的n个（二进制）位求反（即，1变成0，0变成1），x的其余各位保持不变。
*/